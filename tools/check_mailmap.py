"""
Check for duplicate name resolutions in the git contributor log
and suggest .mailmap entries to resolve it.

The raw data processed by this script is generated by:

  git shortlog --summary --numbered --email

Note a subtlety in .mailmap files:

When a contributor uses different *names* with the nsame email address, you need to provide a *canonical name*:

  Frederick <someaddr@domain.org>

Now, `Freddy <someaddr@domain.org` will also be mapped to Frederick.
"""

import subprocess
import collections


shortlog = (
    subprocess.check_output(['git', 'shortlog', '--summary', '--numbered', '--email'])
    .decode('utf-8')
    .strip()
    .split('\n')
)
commits_per_contributor = [
    [col.strip() for col in entry.split('\t')] for entry in shortlog
]

name_emails = collections.defaultdict(list)
email_names = collections.defaultdict(list)
for commits, contributor in sorted(commits_per_contributor, key=lambda entry: entry[1]):
    name = contributor.split('<')[0].strip()
    email = contributor.split('<')[1].split('>')[0]
    name_emails[name].append(email)

    email_names[email].append(name)

log = []
for name, emails in name_emails.items():
    if len(emails) != 1:
        for email in set(emails[1:]):
            log.append(f"{name} <{emails[0]}> <{email}>")

if log:
    print("# Names with multiple emails associated")
    print("# NOTE: First apply these, then re-run the script and")
    print("#       add the canonical names from below.")
    for line in log:
        print(line)


log = []
for email, names in email_names.items():
    if len(names) != 1:
        log.append(f"{names[0]} <{email}>  # {names[1:]}")

if log:
    print("# Emails with multiple names associated with them")
    for line in log:
        print(line)
